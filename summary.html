<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>접근성 분석 리포트 · 게임 접근성</title>
    <link rel="stylesheet" href="style.css">
    <style>
      body.summary-report { padding-bottom: 120px; }
    </style>
  </head>
  <body class="summary-report">
    <main class="shell" aria-labelledby="summary-title">
      <div class="shell-inner">
        <header class="header">
          <div class="brand" aria-label="접근성 분석 리포트">
            <div class="brand-logo" aria-hidden="true">
              <div class="brand-logo-inner">GA</div>
            </div>
            <div class="brand-text-main">
              <span>게임 접근성 측정</span>
              <span id="summary-title">접근성 분석 리포트</span>
            </div>
          </div>
          <div class="header-meta" id="user-summary">세션 정보 로딩 중...</div>
        </header>

        <!-- 1. 상단: User Profile & System Spec -->
        <section class="panel" aria-label="사용자 프로필 및 시스템 스펙">
          <div class="section-title" style="margin-bottom: 16px; color: var(--neon-blue);">
            User Profile & System Spec
          </div>
          <div class="profile-card" id="profile-card"></div>
        </section>

        <!-- 2. 중단: Diagnostic Data 2x2 그리드 -->
        <section class="panel" aria-label="진단 데이터">
          <div class="section-title" style="margin-bottom: 16px; color: var(--neon-blue);">
            Diagnostic Data
          </div>
          <div class="diagnostic-grid">
            <div class="diag-card" id="diag-vision">
              <div class="diag-card-header">
                <span class="diag-card-title">시각</span>
                <span class="badge" id="vision-badge">—</span>
              </div>
              <div class="diag-card-body">
                <div class="fov-canvas-wrap" id="fov-canvas-wrap">
                  <canvas id="fov-canvas" style="max-width:100%; max-height:100%;"></canvas>
                  <div id="fov-placeholder" class="ai-insight-placeholder" style="position:absolute; inset:0; display:flex; align-items:center; justify-content:center; margin:0;">
                    FOV 데이터 없음
                  </div>
                </div>
                <div id="vision-stats" style="margin-top: 12px;"></div>
              </div>
            </div>

            <div class="diag-card" id="diag-motor">
              <div class="diag-card-header">
                <span class="diag-card-title">운동</span>
                <span class="badge" id="motor-badge">—</span>
              </div>
              <div class="diag-card-body">
                <div class="gauge-wrap" id="motor-gauge-wrap">
                  <div class="gauge-ring" id="motor-gauge-ring" style="--gauge-percent: 0;">
                    <div class="gauge-inner" id="motor-gauge-value">—</div>
                  </div>
                  <span style="font-size: 11px; color: var(--text-muted);">반응속도 대비 에임 효율</span>
                </div>
                <div id="motor-stats" style="margin-top: 12px;"></div>
              </div>
            </div>

            <div class="diag-card" id="diag-cognitive">
              <div class="diag-card-header">
                <span class="diag-card-title">인지</span>
                <span class="badge" id="cognitive-badge">—</span>
              </div>
              <div class="diag-card-body" id="cognitive-body">
                <div id="cognitive-stats"></div>
              </div>
            </div>

            <div class="diag-card" id="diag-hearing">
              <div class="diag-card-header">
                <span class="diag-card-title">청각언어</span>
                <span class="badge" id="hearing-badge">—</span>
              </div>
              <div class="diag-card-body" id="hearing-body">
                <div id="hearing-stats"></div>
              </div>
            </div>
          </div>
        </section>

        <!-- 3. 하단: Observer & AI Insight -->
        <section class="panel" aria-label="관찰자 및 AI 인사이트">
          <div class="section-title" style="margin-bottom: 16px; color: var(--neon-blue);">
            Observer & AI Insight
          </div>
          
          <div id="observer-report-section">
            <div id="expert-opinions"></div>
          </div>

          <div class="ai-insight-placeholder" id="ai-insight-placeholder" style="margin-top: 24px;">
            AI 분석 결과가 여기에 표시됩니다.
          </div>
        </section>

        <!-- JSON 미리보기 -->
        <details class="mt-lg" style="margin-top: 24px;">
          <summary class="cursor-pointer text-sm text-muted">
            전체 JSON 데이터 보기 (복사·저장용)
          </summary>
          <pre id="json-preview" class="summary-json" style="max-height: 200px; margin-top: 8px;"></pre>
        </details>

        <!-- 구글 시트 전송 -->
        <div class="panel mt-md">
          <div class="section-title mb-sm">구글 시트 전송</div>
          <p class="text-xs text-muted mb-sm">
            전송 버튼을 누르면 모든 테스트 결과(요약 수치 및 raw JSON)가 구글 시트에 추가됩니다. 성공 시 세션이 비워지며 메인 페이지로 이동합니다.
          </p>
          <div class="flex gap-md flex-wrap items-center">
            <button type="button" class="btn-primary sheets-button" id="send-to-sheets">전송</button>
          </div>
          <p id="sheets-status" class="sheets-status"></p>
        </div>

        <div class="btn-row" style="margin-top: 24px;">
          <button type="button" class="btn-secondary" id="back-to-observer">
            <span class="btn-icon" aria-hidden="true">◀</span>
            <span>관찰자 리포트 작성하기</span>
          </button>
        </div>
      </div>
    </main>

    <!-- Sticky Footer: 최종 전송 버튼 -->
    <div class="sticky-footer" id="sticky-footer">
      <p id="validation-msg" class="validation-error" style="display:none;"></p>
      <button type="button" class="btn-primary" id="final-submit">
        <span class="btn-icon" aria-hidden="true">✓</span>
        <span>최종 전송 (JSON 다운로드)</span>
      </button>
    </div>

    <script src="ga-storage.js"></script>
    <script>
      (function () {
        const FOCUS_POINTS = [
          {id: "P1", x: 5, y: 5, angles: [0, 315, 270]},
          {id: "P2", x: 50, y: 5, angles: [180, 270, 0]},
          {id: "P3", x: 95, y: 5, angles: [180, 225, 270]},
          {id: "P4", x: 5, y: 50, angles: [90, 0, 270]},
          {id: "P5", x: 50, y: 50, angles: [0, 45, 90, 135, 180, 225, 270, 315]},
          {id: "P6", x: 95, y: 50, angles: [90, 180, 270]},
          {id: "P7", x: 5, y: 95, angles: [0, 45, 90]},
          {id: "P8", x: 50, y: 95, angles: [180, 90, 0]},
          {id: "P9", x: 95, y: 95, angles: [180, 135, 90]}
        ];

        const AVG_REACTION_MS = 280;
        const AVG_AIM_INTERVAL_MS = 450;

        function readSession() {
          return (typeof GAStorage !== "undefined" && GAStorage.readSession()) || {};
        }

        function escapeHtml(str) {
          return String(str || "").replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
        }

        function renderProfileCard(session) {
          const labels = {
            userId: "세션 ID", gender: "성별", ageRange: "연령대", disabilityType: "장애 유형",
            platform: "플랫폼", inputDevice: "입력장치", pcResolution: "해상도", windowsDpi: "DPI",
            monitorSizeInch: "모니터(인치)", cpuSpec: "CPU", gpuSpec: "GPU", gameTitle: "게임명", skillTier: "숙련도"
          };
          const keys = ["userId", "gender", "ageRange", "disabilityType", "platform", "inputDevice", "pcResolution", "windowsDpi", "monitorSizeInch", "cpuSpec", "gpuSpec", "gameTitle", "skillTier"];
          const display = { ...session };
          if (session.disabilityTypes && session.disabilityTypes.length > 0) {
            display.disabilityType = session.disabilityTypes.join(", ");
          }
          const el = document.getElementById("profile-card");
          el.innerHTML = keys.filter(k => display[k]).map(k =>
            `<div class="profile-item"><span class="profile-label">${escapeHtml(labels[k])}</span><span class="profile-value">${escapeHtml(String(display[k]))}</span></div>`
          ).join("");
        }

        function drawFovCanvas(fovResults) {
          const canvas = document.getElementById("fov-canvas");
          const placeholder = document.getElementById("fov-placeholder");
          if (!canvas || !fovResults || !Array.isArray(fovResults) || fovResults.length === 0) {
            if (placeholder) placeholder.style.display = "flex";
            return;
          }
          if (placeholder) placeholder.style.display = "none";

          const size = Math.min(280, canvas.parentElement.clientWidth || 280);
          canvas.width = size;
          canvas.height = size;
          const ctx = canvas.getContext("2d");

          const lastRound = fovResults[fovResults.length - 1];
          ctx.fillStyle = "#000";
          ctx.fillRect(0, 0, size, size);

          ctx.strokeStyle = "rgba(34, 211, 238, 0.3)";
          ctx.lineWidth = 1;
          for (let i = 0; i <= 2; i++) {
            const pos = (size / 3) * i;
            ctx.beginPath();
            ctx.moveTo(pos, 0); ctx.lineTo(pos, size);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(0, pos); ctx.lineTo(size, pos);
            ctx.stroke();
          }

          FOCUS_POINTS.forEach(point => {
            const centerX = (size / 100) * point.x;
            const centerY = (size / 100) * point.y;
            const pointData = lastRound[point.id];
            if (!pointData) return;

            point.angles.forEach(angle => {
              const value = pointData[angle];
              if (!value || value === "Blind") return;
              const dist = parseFloat(value);
              const normalizedDist = Math.min(dist / 800, 1);
              const radius = (size / 3) * 0.4 * normalizedDist;
              const angleRad = (angle * Math.PI) / 180;
              const angleRange = (45 * Math.PI) / 180;
              ctx.beginPath();
              ctx.moveTo(centerX, centerY);
              ctx.arc(centerX, centerY, radius, angleRad - angleRange/2, angleRad + angleRange/2);
              ctx.closePath();
              const alpha = 0.3 + normalizedDist * 0.5;
              ctx.fillStyle = `rgba(34, 211, 238, ${alpha})`;
              ctx.fill();
              ctx.strokeStyle = `rgba(34, 211, 238, ${0.5 + normalizedDist * 0.5})`;
              ctx.lineWidth = 2;
              ctx.stroke();
            });
            ctx.fillStyle = "#ff4444";
            ctx.beginPath();
            ctx.arc(centerX, centerY, 4, 0, Math.PI * 2);
            ctx.fill();
          });
        }

        function statRow(label, value, delayPercent) {
          const cls = delayPercent != null ? (delayPercent > 10 ? "delay" : "good") : "";
          const badge = delayPercent != null ? `<span class="stat-badge ${cls}">${delayPercent > 0 ? '+' : ''}${delayPercent}%</span>` : "";
          return `<div class="stat-row"><span>${escapeHtml(label)}</span><span>${escapeHtml(String(value))} ${badge}</span></div>`;
        }

        function renderVisionCard(vision) {
          document.getElementById("vision-badge").textContent = vision ? "데이터 있음" : "—";
          document.getElementById("vision-badge").className = vision ? "badge success" : "badge";

          if (vision && vision.fovResults) drawFovCanvas(vision.fovResults);

          const stats = document.getElementById("vision-stats");
          if (!vision) {
            stats.innerHTML = "<div class=\"text-muted text-sm\">데이터 없음</div>";
            return;
          }

          let html = "";
          if (vision.reactionTime) {
            const avg = vision.reactionTime.average;
            const delay = avg ? Math.round(((avg - AVG_REACTION_MS) / AVG_REACTION_MS) * 100) : null;
            html += statRow("반응속도 평균", avg + " ms", delay);
          }
          if (vision.fontReadability) {
            html += statRow("최소 가독 폰트", vision.fontReadability.minFontSize + " px", null);
          }
          if (vision.aimTrainer) {
            const ai = vision.aimTrainer.averageInterval;
            const delay = ai ? Math.round(((ai - AVG_AIM_INTERVAL_MS) / AVG_AIM_INTERVAL_MS) * 100) : null;
            html += statRow("에임 간격 평균", ai + " ms", delay);
          }
          stats.innerHTML = html || "<div class=\"text-muted text-sm\">데이터 없음</div>";
        }

        function renderMotorCard(motor) {
          document.getElementById("motor-badge").textContent = motor ? "데이터 있음" : "—";
          document.getElementById("motor-badge").className = motor ? "badge success" : "badge";

          const rt = motor && motor.reactionTime ? motor.reactionTime.average : null;
          const aim = motor && motor.aimTrainer ? motor.aimTrainer.averageInterval : null;
          let ratioPercent = 0;
          if (rt && aim && rt > 0) {
            ratioPercent = Math.min(100, Math.round((rt / aim) * 100));
          }
          const ring = document.getElementById("motor-gauge-ring");
          const val = document.getElementById("motor-gauge-value");
          if (ring) ring.style.setProperty("--gauge-percent", ratioPercent);
          if (val) val.textContent = aim ? ratioPercent + "%" : "—";

          const stats = document.getElementById("motor-stats");
          if (!motor) {
            stats.innerHTML = "<div class=\"text-muted text-sm\">데이터 없음</div>";
            return;
          }
          let html = "";
          if (motor.reactionTime) {
            const avg = motor.reactionTime.average;
            const delay = avg ? Math.round(((avg - AVG_REACTION_MS) / AVG_REACTION_MS) * 100) : null;
            html += statRow("반응속도", avg + " ms", delay);
          }
          if (motor.aimTrainer) {
            const ai = motor.aimTrainer.averageInterval;
            const delay = ai ? Math.round(((ai - AVG_AIM_INTERVAL_MS) / AVG_AIM_INTERVAL_MS) * 100) : null;
            html += statRow("에임 간격", ai + " ms", delay);
          }
          if (motor.precision) {
            html += statRow("정밀도 오차", motor.precision.averageError + " px", null);
            if (motor.precision.totalCompletionTimeSec != null) html += statRow("정밀도 소요 시간", motor.precision.totalCompletionTimeSec + " 초", null);
          }
          if (motor.fatigue) html += statRow("피로도 지수", motor.fatigue.fatigueIndex + "%", null);
          if (motor.switching_latency) html += statRow("디바이스 전환 지연", motor.switching_latency.average + " ms", null);
          var oneHandScore = calcOneHandEfficiency(motor);
          if (oneHandScore != null) {
            html += statRow("한 손 조작 효율성", oneHandScore + " / 100", null);
          }
          stats.innerHTML = html || "<div class=\"text-muted text-sm\">데이터 없음</div>";
        }

        /** switching_latency 기반 한 손 조작 효율성 점수 (0~100). key_map_range 삭제로 switching만 사용. */
        function calcOneHandEfficiency(motor) {
          if (!motor) return null;
          var sw = motor.switching_latency && motor.switching_latency.average != null ? motor.switching_latency.average : null;
          if (sw == null) return null;
          var switchScore = 100 * (1 - Math.min(1, sw / 600));
          return Math.round(switchScore);
        }

        function renderCognitiveCard(cognitive) {
          document.getElementById("cognitive-badge").textContent = cognitive ? "데이터 있음" : "—";
          document.getElementById("cognitive-badge").className = cognitive ? "badge success" : "badge";

          const stats = document.getElementById("cognitive-stats");
          if (!cognitive) {
            stats.innerHTML = "<div class=\"text-muted text-sm\">데이터 없음</div>";
            return;
          }
          let html = "";
          if (cognitive.sequenceMemory) html += statRow("순서 기억 테스트", cognitive.sequenceMemory.maxLevel + " 레벨", null);
          if (cognitive.goNoGo) html += statRow("반응 통제 테스트 성공률", (cognitive.goNoGo.successRate * 100).toFixed(1) + "%", null);
          if (cognitive.dividedAttention) html += statRow("동시 처리 테스트", cognitive.dividedAttention.starSuccessRate * 100 + "%", null);
          if (cognitive.readingSpeed) html += statRow("핵심 파악 테스트", cognitive.readingSpeed.successRate * 100 + "%", null);
          stats.innerHTML = html || "<div class=\"text-muted text-sm\">데이터 없음</div>";
        }

        function renderHearingCard(hearing) {
          document.getElementById("hearing-badge").textContent = hearing ? "데이터 있음" : "—";
          document.getElementById("hearing-badge").className = hearing ? "badge success" : "badge";

          const stats = document.getElementById("hearing-stats");
          if (!hearing) {
            stats.innerHTML = "<div class=\"text-muted text-sm\">데이터 없음</div>";
            return;
          }
          let html = "";
          const hn = hearing.hearingNumber;
          if (hn && (hn.left != null || hn.right != null)) {
            if (hn.left != null) html += statRow("히어링 넘버(dB) 좌(L)", hn.left, null);
            if (hn.right != null) html += statRow("히어링 넘버(dB) 우(R)", hn.right, null);
          } else if (hearing.overallDb != null) {
            html += statRow("전체 청력(dB)", hearing.overallDb, null);
          }
          const cap = hearing.hearingCapacity;
          if (cap && (cap.left != null || cap.right != null)) {
            if (cap.left != null) html += statRow("청각 수용력(%) 좌(L)", cap.left, null);
            if (cap.right != null) html += statRow("청각 수용력(%) 우(R)", cap.right, null);
          }
          if (hearing.speechClarityPercent != null) html += statRow("수음 명료도", hearing.speechClarityPercent.toFixed(0) + "%", null);
          if (hearing.articulationTest && hearing.articulationTest.matchRate != null) html += statRow("발화 인식 일치도", hearing.articulationTest.matchRate + "%", null);
          if (hearing.speechClarityRating != null) html += statRow("관찰자 발화 명료도", hearing.speechClarityRating + "/5", null);
          stats.innerHTML = html || "<div class=\"text-muted text-sm\">데이터 없음</div>";
        }

        function renderExpertOpinions(observer) {
          const el = document.getElementById("expert-opinions");
          if (!observer) {
            el.innerHTML = "<div class=\"expert-opinion\"><div class=\"expert-opinion-label\">Expert Opinion</div><div class=\"expert-opinion-text\">관찰자 리포트가 없습니다.</div></div>";
            return;
          }
          const items = [
            { label: "이탈/포기 사유", text: observer.quitReason },
            { label: "대체 행동 패턴", text: observer.altBehavior },
            { label: "핵심 분석 요약", text: observer.analysisSummary }
          ].filter(i => i.text);
          el.innerHTML = items.map(i =>
            `<div class="expert-opinion"><div class="expert-opinion-label">${escapeHtml(i.label)}</div><div class="expert-opinion-text">"${escapeHtml(i.text)}"</div></div>`
          ).join("") || "<div class=\"expert-opinion\"><div class=\"expert-opinion-text\">관찰자 리포트가 비어 있습니다.</div></div>";
        }

        function validateSession(session) {
          const errs = [];
          if (!session.userId && !session.id) errs.push("세션 ID가 없습니다.");
          const hasDisability = (session.disabilityTypes && session.disabilityTypes.length > 0) || session.disabilityType;
          if (!hasDisability) errs.push("장애 유형이 선택되지 않았습니다.");
          if (!session.user_data) errs.push("측정 데이터(user_data)가 없습니다.");
          try {
            JSON.stringify(session);
          } catch (e) {
            errs.push("JSON 직렬화 오류: " + (e.message || "알 수 없음"));
          }
          return errs;
        }

        /** FOV 결과에서 9개 포인트·각도 슬롯 중 'Blind' 판정 비율 (0~1) */
        function calcFovBlindRate(fovResults) {
          if (!fovResults) return null;
          const rounds = Array.isArray(fovResults) ? fovResults : [fovResults];
          let total = 0, blind = 0;
          rounds.forEach(round => {
            if (!round || typeof round !== "object") return;
            ["P1","P2","P3","P4","P5","P6","P7","P8","P9"].forEach(pid => {
              const pointData = round[pid];
              if (!pointData || typeof pointData !== "object") return;
              Object.keys(pointData).forEach(angle => {
                total += 1;
                if (pointData[angle] === "Blind") blind += 1;
              });
            });
          });
          return total === 0 ? null : blind / total;
        }

        /** 숫자 배열 평균 (없으면 null) */
        function avg(arr) {
          if (!Array.isArray(arr) || arr.length === 0) return null;
          const sum = arr.reduce((a, b) => a + Number(b), 0);
          return sum / arr.length;
        }

        /**
         * monitor_inch, resolution으로 mm/px 변환 계수 계산.
         * @returns {number|null} mm per pixel (대각선 기준), 변환 불가 시 null
         */
        function calcMmPerPx(monitorInch, resolution) {
          if (!monitorInch || !resolution) return null;
          const inch = parseFloat(String(monitorInch).replace(/[^\d.]/g, ""));
          if (isNaN(inch) || inch <= 0) return null;
          const m = String(resolution).match(/(\d+)\s*[x×]\s*(\d+)/i);
          if (!m) return null;
          const w = parseInt(m[1], 10);
          const h = parseInt(m[2], 10);
          if (!w || !h) return null;
          const diagonalPx = Math.sqrt(w * w + h * h);
          const diagonalMm = inch * 25.4;
          return diagonalMm / diagonalPx;
        }

        /**
         * 픽셀 값을 실제 모니터 물리 크기(mm)로 변환.
         * @param {number} px - 픽셀 값
         * @param {string|number} monitorInch - 모니터 대각선(인치)
         * @param {string} resolution - 해상도 (예: "1920x1080")
         * @returns {number|null} mm 단위 물리 크기, 변환 불가 시 null
         */
        function pxToMm(px, monitorInch, resolution) {
          if (px == null || isNaN(Number(px))) return null;
          const factor = calcMmPerPx(monitorInch, resolution);
          return factor != null ? Math.round(Number(px) * factor * 100) / 100 : null;
        }

        /** 구글 시트 헤더 순서 (이 순서와 시트 첫 행 헤더가 일치해야 함) */
        const SHEETS_HEADER_ORDER = [
          "timestamp", "user_id", "age", "gender", "monitor_inch", "resolution", "viewing_distance", "disability_type",
          "vision_rt_avg", "vision_aim_avg", "fov_blind_rate", "readable_font_size", "readable_font_size_mm",
          "motor_rt_avg", "motor_aim_avg", "motor_switch_latency", "key_reach_score", "burst_speed_peak", "fatigue_index", "motor_precision_error_mm",
          "seq_memory_score", "go_nogo_accuracy",
          "hearing_hearing_number_left", "hearing_hearing_number_right", "hearing_capacity_left", "hearing_capacity_right",
          "hearing_speech_clarity_percent", "hearing_articulation_match_rate", "hearing_observer_clarity_rating",
          "input_device", "assistive_device",
          "calibration_mm_per_px",
          "raw_vision_data", "raw_motor_data", "raw_cognitive_data", "raw_hearing_data", "observer_report"
        ];

        /**
         * 구글 시트 헤더 순서에 맞춘 전송용 객체 생성. SHEETS_HEADER_ORDER와 시트 첫 행 헤더가 일치해야 함.
         */
        function buildSheetsRowPayload(session) {
          const ud = session.user_data || {};
          const vision = ud.vision_results || {};
          const motor = ud.motor_results || {};
          const cognitive = ud.cognitive_results || {};
          const hearing = ud.hearing_results || {};

          const visionRtTrials = vision.reactionTime && vision.reactionTime.trials;
          const vision_rt_avg = visionRtTrials && visionRtTrials.length
            ? Math.round(avg(visionRtTrials))
            : (vision.reactionTime && vision.reactionTime.average) != null ? vision.reactionTime.average : null;
          const vision_aim_avg = vision.aimTrainer && (vision.aimTrainer.averageInterval != null)
            ? vision.aimTrainer.averageInterval
            : null;
          const fov_blind_rate = calcFovBlindRate(vision.fovResults);
          const readable_font_size = vision.fontReadability && vision.fontReadability.minFontSize != null
            ? vision.fontReadability.minFontSize
            : null;

          const mmPerPx = calcMmPerPx(session.monitorSizeInch, session.pcResolution);
          const readable_font_size_mm = readable_font_size != null && mmPerPx != null
            ? Math.round(readable_font_size * mmPerPx * 100) / 100
            : null;
          const motor_precision_error_mm = motor.precision && motor.precision.averageError != null && mmPerPx != null
            ? Math.round(motor.precision.averageError * mmPerPx * 100) / 100
            : null;

          const motorRtTrials = motor.reactionTime && motor.reactionTime.trials;
          const motor_rt_avg = motorRtTrials && motorRtTrials.length
            ? Math.round(avg(motorRtTrials))
            : (motor.reactionTime && motor.reactionTime.average) != null ? motor.reactionTime.average : null;
          const motor_aim_avg = motor.aimTrainer && (motor.aimTrainer.averageInterval != null)
            ? motor.aimTrainer.averageInterval
            : null;
          const motor_switch_latency = motor.switching_latency && (motor.switching_latency.average != null)
            ? motor.switching_latency.average
            : null;
          let key_reach_score = motor.key_map_range && (motor.key_map_range.maxReachStage != null)
            ? motor.key_map_range.maxReachStage
            : null;
          if (key_reach_score == null && motor.key_map_range && motor.key_map_range.trials && motor.key_map_range.trials.length) {
            const correctWithStage = motor.key_map_range.trials.filter(function (t) { return t.correct && (t.stageIndex != null); });
            if (correctWithStage.length) {
              key_reach_score = Math.max.apply(null, correctWithStage.map(function (t) { return t.stageIndex; }));
            }
          }
          const burst_speed_peak = motor.burstSpeed
            ? (motor.burstSpeed.keyboard && motor.burstSpeed.mouse
              ? Math.max(
                  motor.burstSpeed.keyboard.inputsPerSecond || 0,
                  motor.burstSpeed.mouse.inputsPerSecond || 0
                )
              : (motor.burstSpeed.maxInputsPerSecond != null ? motor.burstSpeed.maxInputsPerSecond : null))
            : null;
          let fatigue_index = null;
          if (motor.fatigue) {
            if (motor.fatigue.fatigue_log && motor.fatigue.fatigue_log.length >= 6 && motor.fatigue.fatigue_log[0] > 0) {
              fatigue_index = Math.round((motor.fatigue.fatigue_log[5] / motor.fatigue.fatigue_log[0]) * 1000) / 10;
            } else if (motor.fatigue.fatigueIndex != null) {
              fatigue_index = motor.fatigue.fatigueIndex;
            }
          }

          const seq_memory_score = cognitive.sequenceMemory && cognitive.sequenceMemory.maxLevel != null
            ? cognitive.sequenceMemory.maxLevel
            : null;
          const go_nogo_accuracy = cognitive.goNoGo && cognitive.goNoGo.successRate != null
            ? cognitive.goNoGo.successRate
            : null;

          const hearing_hearing_number_left = hearing.hearingNumber && hearing.hearingNumber.left != null ? hearing.hearingNumber.left : null;
          const hearing_hearing_number_right = hearing.hearingNumber && hearing.hearingNumber.right != null ? hearing.hearingNumber.right : null;
          const hearing_capacity_left = hearing.hearingCapacity && hearing.hearingCapacity.left != null ? hearing.hearingCapacity.left : null;
          const hearing_capacity_right = hearing.hearingCapacity && hearing.hearingCapacity.right != null ? hearing.hearingCapacity.right : null;
          const hearing_speech_clarity_percent = hearing.speechClarityPercent != null ? hearing.speechClarityPercent : null;
          const hearing_articulation_match_rate = hearing.articulationTest && hearing.articulationTest.matchRate != null ? hearing.articulationTest.matchRate : null;
          const hearing_observer_clarity_rating = hearing.speechClarityRating != null ? hearing.speechClarityRating : null;

          let raw_vision_data = vision && Object.keys(vision).length ? vision : null;
          if (raw_vision_data && mmPerPx != null) {
            raw_vision_data = JSON.parse(JSON.stringify(raw_vision_data));
            if (raw_vision_data.fontReadability && raw_vision_data.fontReadability.minFontSize != null) {
              raw_vision_data.fontReadability.physical_size_mm = pxToMm(
                raw_vision_data.fontReadability.minFontSize,
                session.monitorSizeInch,
                session.pcResolution
              );
            }
          }
          const baseMotor = motor && typeof motor === "object" ? motor : {};
          const hasMotorData = Object.keys(baseMotor).length > 0;
          const hasAssistiveInfo = (session.assistiveDevice && String(session.assistiveDevice).trim()) || (session.inputDevice && String(session.inputDevice).trim());
          let motorWithMeta = (hasMotorData || hasAssistiveInfo)
            ? Object.assign({}, baseMotor, {
                _metadata: {
                  assistiveDevice: session.assistiveDevice != null ? session.assistiveDevice : "",
                  inputDevice: session.inputDevice != null ? session.inputDevice : "",
                }
              })
            : null;
          if (motorWithMeta && motorWithMeta.precision && motorWithMeta.precision.averageError != null && mmPerPx != null) {
            motorWithMeta = Object.assign({}, motorWithMeta, {
              precision: Object.assign({}, motorWithMeta.precision, {
                physical_size_mm: pxToMm(
                  motorWithMeta.precision.averageError,
                  session.monitorSizeInch,
                  session.pcResolution
                )
              })
            });
          }
          const raw_motor_data = motorWithMeta;
          const raw_cognitive_data = cognitive && Object.keys(cognitive).length ? cognitive : null;
          const raw_hearing_data = hearing && Object.keys(hearing).length ? hearing : null;
          const observer_report = session.observer_report && typeof session.observer_report === "object"
            ? session.observer_report
            : null;

          const raw = {
            timestamp: new Date().toISOString(),
            user_id: session.userId || session.id || "",
            age: session.ageRange != null ? session.ageRange : "",
            gender: session.gender != null ? session.gender : "",
            monitor_inch: session.monitorSizeInch != null ? session.monitorSizeInch : "",
            resolution: session.pcResolution != null ? session.pcResolution : "",
            viewing_distance: session.viewingDistance != null ? session.viewingDistance : "",
            disability_type: (session.disabilityTypes && session.disabilityTypes.length)
              ? session.disabilityTypes.join(", ")
              : (session.disabilityType != null ? session.disabilityType : ""),
            vision_rt_avg,
            vision_aim_avg,
            fov_blind_rate,
            readable_font_size,
            readable_font_size_mm,
            motor_rt_avg,
            motor_aim_avg,
            motor_switch_latency,
            key_reach_score,
            burst_speed_peak,
            fatigue_index,
            motor_precision_error_mm,
            seq_memory_score,
            go_nogo_accuracy,
            hearing_hearing_number_left,
            hearing_hearing_number_right,
            hearing_capacity_left,
            hearing_capacity_right,
            hearing_speech_clarity_percent,
            hearing_articulation_match_rate,
            hearing_observer_clarity_rating,
            input_device: session.inputDevice != null ? session.inputDevice : "",
            assistive_device: session.assistiveDevice != null ? session.assistiveDevice : "",
            calibration_mm_per_px: mmPerPx != null ? Math.round(mmPerPx * 10000) / 10000 : null,
            raw_vision_data,
            raw_motor_data,
            raw_cognitive_data,
            raw_hearing_data,
            observer_report,
          };
          const ordered = {};
          SHEETS_HEADER_ORDER.forEach(function (k) {
            if (k in raw) ordered[k] = raw[k];
          });
          Object.keys(raw).forEach(function (k) {
            if (!(k in ordered)) ordered[k] = raw[k];
          });
          return ordered;
        }

        /** 세션 저장소 비우기 (전송 완료 후 호출) */
        function clearSessionStorage() {
          try {
            sessionStorage.removeItem("user_data");
            sessionStorage.removeItem("ga_current_session");
            localStorage.removeItem("ga_current_session");
          } catch (e) {}
        }

        function render(session) {
          renderProfileCard(session);
          renderVisionCard(session.user_data && session.user_data.vision_results);
          renderMotorCard(session.user_data && session.user_data.motor_results);
          renderCognitiveCard(session.user_data && session.user_data.cognitive_results);
          renderHearingCard(session.user_data && session.user_data.hearing_results);
          renderExpertOpinions(session.observer_report);
          document.getElementById("json-preview").textContent = JSON.stringify(session, null, 2);

          const id = session.userId || session.id || "-";
          const disability = (session.disabilityTypes && session.disabilityTypes.length > 0)
            ? session.disabilityTypes.join(", ")
            : (session.disabilityType || "-");
          document.getElementById("user-summary").innerHTML =
            "세션 <strong>" + escapeHtml(id) + "</strong> · 장애 <strong>" + escapeHtml(disability) + "</strong>";
        }

        document.getElementById("final-submit").addEventListener("click", () => {
          const session = readSession();
          const errs = validateSession(session);
          const msgEl = document.getElementById("validation-msg");

          if (errs.length > 0) {
            msgEl.textContent = "유효성 검사 실패: " + errs.join(" ");
            msgEl.style.display = "block";
            msgEl.classList.add("validation-error");
            return;
          }

          msgEl.style.display = "none";
          try {
            const blob = new Blob([JSON.stringify(session, null, 2)], { type: "application/json" });
            const a = document.createElement("a");
            a.href = URL.createObjectURL(blob);
            a.download = "ga_report_" + (session.userId || session.id || "export") + "_" + new Date().toISOString().slice(0, 10) + ".json";
            a.click();
            URL.revokeObjectURL(a.href);
          } catch (e) {
            msgEl.textContent = "다운로드 오류: " + (e.message || "알 수 없음");
            msgEl.style.display = "block";
          }
        });

        const DEPLOYED_SHEETS_URL = "https://script.google.com/macros/s/AKfycbxpzl0a9g-zJJ_vH0MghogtE6DNts036TudVKGzIETHjeek4z2WycCZL_Gj35j6qwsE/exec";
        const sendToSheetsBtn = document.getElementById("send-to-sheets");
        const sheetsStatusEl = document.getElementById("sheets-status");
        const sendBtnOriginalText = sendToSheetsBtn ? sendToSheetsBtn.textContent : "전송";

        function doSheetsSubmit() {
          if (window.location.protocol === "file:") {
            if (sheetsStatusEl) {
              sheetsStatusEl.textContent = "파일 직접 열기(file://)에서는 전송이 불가합니다. 터미널에서 'python3 -m http.server 8080' 후 localhost:8080 으로 접속해 주세요.";
              sheetsStatusEl.style.color = "#f97373";
            }
            return;
          }
          const session = readSession();
          const errs = validateSession(session);
          if (errs.length > 0) {
            if (sheetsStatusEl) {
              sheetsStatusEl.textContent = "유효성 검사 실패: " + errs.join(" ");
              sheetsStatusEl.style.color = "#f97373";
            }
            return;
          }
          if (sendToSheetsBtn) {
            sendToSheetsBtn.disabled = true;
            sendToSheetsBtn.textContent = "전송 중...";
          }
          if (sheetsStatusEl) {
            sheetsStatusEl.textContent = "";
            sheetsStatusEl.style.color = "inherit";
          }

          const payload = buildSheetsRowPayload(session);
          fetch(DEPLOYED_SHEETS_URL, {
            method: "POST",
            mode: "no-cors",
            headers: {},
            body: JSON.stringify(payload),
          });
          clearSessionStorage();
          alert("전송 시도 완료");
          window.location.href = "index.html";
        }

        if (sendToSheetsBtn) {
          sendToSheetsBtn.addEventListener("click", doSheetsSubmit);
        }

        document.getElementById("back-to-observer").addEventListener("click", () => {
          window.location.href = "observer_report.html";
        });

        function init() {
          const session = readSession();
          render(session);
        }

        if (document.readyState === "loading") {
          document.addEventListener("DOMContentLoaded", init);
        } else {
          init();
        }
      })();
    </script>
  </body>
</html>
